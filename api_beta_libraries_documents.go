/*
Mistral AI API

Our Chat Completion and Embeddings APIs specification. Create your account on [La Plateforme](https://console.mistral.ai) to get access and read the [docs](https://docs.mistral.ai) to learn how to use it.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistral

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type BetaLibrariesDocumentsAPI interface {

	/*
	LibrariesDocumentsDeleteV1 Delete a document.

	Given a library and a document in that library, delete that document. The document will be deleted from the library and the search index.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsDeleteV1Request
	*/
	LibrariesDocumentsDeleteV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsDeleteV1Request

	// LibrariesDocumentsDeleteV1Execute executes the request
	LibrariesDocumentsDeleteV1Execute(r ApiLibrariesDocumentsDeleteV1Request) (*http.Response, error)

	/*
	LibrariesDocumentsGetExtractedTextSignedUrlV1 Retrieve the signed URL of text extracted from a given document.

	Given a library and a document in that library, retrieve the signed URL of text extracted. For documents that are sent to the OCR this returns the result of the OCR queries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request
	*/
	LibrariesDocumentsGetExtractedTextSignedUrlV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request

	// LibrariesDocumentsGetExtractedTextSignedUrlV1Execute executes the request
	//  @return string
	LibrariesDocumentsGetExtractedTextSignedUrlV1Execute(r ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request) (string, *http.Response, error)

	/*
	LibrariesDocumentsGetSignedUrlV1 Retrieve the signed URL of a specific document.

	Given a library and a document in that library, retrieve the signed URL of a specific document.The url will expire after 30 minutes and can be accessed by anyone with the link.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsGetSignedUrlV1Request
	*/
	LibrariesDocumentsGetSignedUrlV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetSignedUrlV1Request

	// LibrariesDocumentsGetSignedUrlV1Execute executes the request
	//  @return string
	LibrariesDocumentsGetSignedUrlV1Execute(r ApiLibrariesDocumentsGetSignedUrlV1Request) (string, *http.Response, error)

	/*
	LibrariesDocumentsGetStatusV1 Retrieve the processing status of a specific document.

	Given a library and a document in that library, retrieve the processing status of that document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsGetStatusV1Request
	*/
	LibrariesDocumentsGetStatusV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetStatusV1Request

	// LibrariesDocumentsGetStatusV1Execute executes the request
	//  @return ProcessingStatusOut
	LibrariesDocumentsGetStatusV1Execute(r ApiLibrariesDocumentsGetStatusV1Request) (*ProcessingStatusOut, *http.Response, error)

	/*
	LibrariesDocumentsGetTextContentV1 Retrieve the text content of a specific document.

	Given a library and a document in that library, you can retrieve the text content of that document if it exists. For documents like pdf, docx and pptx the text content results from our processing using Mistral OCR.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsGetTextContentV1Request
	*/
	LibrariesDocumentsGetTextContentV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetTextContentV1Request

	// LibrariesDocumentsGetTextContentV1Execute executes the request
	//  @return DocumentTextContent
	LibrariesDocumentsGetTextContentV1Execute(r ApiLibrariesDocumentsGetTextContentV1Request) (*DocumentTextContent, *http.Response, error)

	/*
	LibrariesDocumentsGetV1 Retrieve the metadata of a specific document.

	Given a library and a document in this library, you can retrieve the metadata of that document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsGetV1Request
	*/
	LibrariesDocumentsGetV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetV1Request

	// LibrariesDocumentsGetV1Execute executes the request
	//  @return DocumentOut
	LibrariesDocumentsGetV1Execute(r ApiLibrariesDocumentsGetV1Request) (*DocumentOut, *http.Response, error)

	/*
	LibrariesDocumentsListV1 List document in a given library.

	Given a library, lists the document that have been uploaded to that library.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@return ApiLibrariesDocumentsListV1Request
	*/
	LibrariesDocumentsListV1(ctx context.Context, libraryId string) ApiLibrariesDocumentsListV1Request

	// LibrariesDocumentsListV1Execute executes the request
	//  @return ListDocumentOut
	LibrariesDocumentsListV1Execute(r ApiLibrariesDocumentsListV1Request) (*ListDocumentOut, *http.Response, error)

	/*
	LibrariesDocumentsReprocessV1 Reprocess a document.

	Given a library and a document in that library, reprocess that document, it will be billed again.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsReprocessV1Request
	*/
	LibrariesDocumentsReprocessV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsReprocessV1Request

	// LibrariesDocumentsReprocessV1Execute executes the request
	LibrariesDocumentsReprocessV1Execute(r ApiLibrariesDocumentsReprocessV1Request) (*http.Response, error)

	/*
	LibrariesDocumentsUpdateV1 Update the metadata of a specific document.

	Given a library and a document in that library, update the name of that document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@param documentId
	@return ApiLibrariesDocumentsUpdateV1Request
	*/
	LibrariesDocumentsUpdateV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsUpdateV1Request

	// LibrariesDocumentsUpdateV1Execute executes the request
	//  @return DocumentOut
	LibrariesDocumentsUpdateV1Execute(r ApiLibrariesDocumentsUpdateV1Request) (*DocumentOut, *http.Response, error)

	/*
	LibrariesDocumentsUploadV1 Upload a new document.

	Given a library, upload a new document to that library. It is queued for processing, it status will change it has been processed. The processing has to be completed in order be discoverable for the library search

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param libraryId
	@return ApiLibrariesDocumentsUploadV1Request
	*/
	LibrariesDocumentsUploadV1(ctx context.Context, libraryId string) ApiLibrariesDocumentsUploadV1Request

	// LibrariesDocumentsUploadV1Execute executes the request
	//  @return DocumentOut
	LibrariesDocumentsUploadV1Execute(r ApiLibrariesDocumentsUploadV1Request) (*DocumentOut, *http.Response, error)
}

// BetaLibrariesDocumentsAPIService BetaLibrariesDocumentsAPI service
type BetaLibrariesDocumentsAPIService service

type ApiLibrariesDocumentsDeleteV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsDeleteV1Request) Execute() (*http.Response, error) {
	return r.ApiService.LibrariesDocumentsDeleteV1Execute(r)
}

/*
LibrariesDocumentsDeleteV1 Delete a document.

Given a library and a document in that library, delete that document. The document will be deleted from the library and the search index.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsDeleteV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsDeleteV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsDeleteV1Request {
	return ApiLibrariesDocumentsDeleteV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsDeleteV1Execute(r ApiLibrariesDocumentsDeleteV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsDeleteV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request) Execute() (string, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsGetExtractedTextSignedUrlV1Execute(r)
}

/*
LibrariesDocumentsGetExtractedTextSignedUrlV1 Retrieve the signed URL of text extracted from a given document.

Given a library and a document in that library, retrieve the signed URL of text extracted. For documents that are sent to the OCR this returns the result of the OCR queries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetExtractedTextSignedUrlV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request {
	return ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return string
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetExtractedTextSignedUrlV1Execute(r ApiLibrariesDocumentsGetExtractedTextSignedUrlV1Request) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsGetExtractedTextSignedUrlV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}/extracted-text-signed-url"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsGetSignedUrlV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsGetSignedUrlV1Request) Execute() (string, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsGetSignedUrlV1Execute(r)
}

/*
LibrariesDocumentsGetSignedUrlV1 Retrieve the signed URL of a specific document.

Given a library and a document in that library, retrieve the signed URL of a specific document.The url will expire after 30 minutes and can be accessed by anyone with the link.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsGetSignedUrlV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetSignedUrlV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetSignedUrlV1Request {
	return ApiLibrariesDocumentsGetSignedUrlV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return string
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetSignedUrlV1Execute(r ApiLibrariesDocumentsGetSignedUrlV1Request) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsGetSignedUrlV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}/signed-url"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsGetStatusV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsGetStatusV1Request) Execute() (*ProcessingStatusOut, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsGetStatusV1Execute(r)
}

/*
LibrariesDocumentsGetStatusV1 Retrieve the processing status of a specific document.

Given a library and a document in that library, retrieve the processing status of that document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsGetStatusV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetStatusV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetStatusV1Request {
	return ApiLibrariesDocumentsGetStatusV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return ProcessingStatusOut
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetStatusV1Execute(r ApiLibrariesDocumentsGetStatusV1Request) (*ProcessingStatusOut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessingStatusOut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsGetStatusV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsGetTextContentV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsGetTextContentV1Request) Execute() (*DocumentTextContent, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsGetTextContentV1Execute(r)
}

/*
LibrariesDocumentsGetTextContentV1 Retrieve the text content of a specific document.

Given a library and a document in that library, you can retrieve the text content of that document if it exists. For documents like pdf, docx and pptx the text content results from our processing using Mistral OCR.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsGetTextContentV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetTextContentV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetTextContentV1Request {
	return ApiLibrariesDocumentsGetTextContentV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DocumentTextContent
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetTextContentV1Execute(r ApiLibrariesDocumentsGetTextContentV1Request) (*DocumentTextContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentTextContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsGetTextContentV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}/text_content"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsGetV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsGetV1Request) Execute() (*DocumentOut, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsGetV1Execute(r)
}

/*
LibrariesDocumentsGetV1 Retrieve the metadata of a specific document.

Given a library and a document in this library, you can retrieve the metadata of that document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsGetV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsGetV1Request {
	return ApiLibrariesDocumentsGetV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DocumentOut
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsGetV1Execute(r ApiLibrariesDocumentsGetV1Request) (*DocumentOut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsGetV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsListV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	search *string
	pageSize *int32
	page *int32
	sortBy *string
	sortOrder *string
}

func (r ApiLibrariesDocumentsListV1Request) Search(search string) ApiLibrariesDocumentsListV1Request {
	r.search = &search
	return r
}

func (r ApiLibrariesDocumentsListV1Request) PageSize(pageSize int32) ApiLibrariesDocumentsListV1Request {
	r.pageSize = &pageSize
	return r
}

func (r ApiLibrariesDocumentsListV1Request) Page(page int32) ApiLibrariesDocumentsListV1Request {
	r.page = &page
	return r
}

func (r ApiLibrariesDocumentsListV1Request) SortBy(sortBy string) ApiLibrariesDocumentsListV1Request {
	r.sortBy = &sortBy
	return r
}

func (r ApiLibrariesDocumentsListV1Request) SortOrder(sortOrder string) ApiLibrariesDocumentsListV1Request {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiLibrariesDocumentsListV1Request) Execute() (*ListDocumentOut, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsListV1Execute(r)
}

/*
LibrariesDocumentsListV1 List document in a given library.

Given a library, lists the document that have been uploaded to that library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @return ApiLibrariesDocumentsListV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsListV1(ctx context.Context, libraryId string) ApiLibrariesDocumentsListV1Request {
	return ApiLibrariesDocumentsListV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return ListDocumentOut
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsListV1Execute(r ApiLibrariesDocumentsListV1Request) (*ListDocumentOut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDocumentOut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsListV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortBy = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortOrder = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsReprocessV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
}

func (r ApiLibrariesDocumentsReprocessV1Request) Execute() (*http.Response, error) {
	return r.ApiService.LibrariesDocumentsReprocessV1Execute(r)
}

/*
LibrariesDocumentsReprocessV1 Reprocess a document.

Given a library and a document in that library, reprocess that document, it will be billed again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsReprocessV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsReprocessV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsReprocessV1Request {
	return ApiLibrariesDocumentsReprocessV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsReprocessV1Execute(r ApiLibrariesDocumentsReprocessV1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsReprocessV1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}/reprocess"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsUpdateV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	documentId string
	documentUpdateIn *DocumentUpdateIn
}

func (r ApiLibrariesDocumentsUpdateV1Request) DocumentUpdateIn(documentUpdateIn DocumentUpdateIn) ApiLibrariesDocumentsUpdateV1Request {
	r.documentUpdateIn = &documentUpdateIn
	return r
}

func (r ApiLibrariesDocumentsUpdateV1Request) Execute() (*DocumentOut, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsUpdateV1Execute(r)
}

/*
LibrariesDocumentsUpdateV1 Update the metadata of a specific document.

Given a library and a document in that library, update the name of that document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @param documentId
 @return ApiLibrariesDocumentsUpdateV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsUpdateV1(ctx context.Context, libraryId string, documentId string) ApiLibrariesDocumentsUpdateV1Request {
	return ApiLibrariesDocumentsUpdateV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DocumentOut
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsUpdateV1Execute(r ApiLibrariesDocumentsUpdateV1Request) (*DocumentOut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsUpdateV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.documentUpdateIn == nil {
		return localVarReturnValue, nil, reportError("documentUpdateIn is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.documentUpdateIn
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLibrariesDocumentsUploadV1Request struct {
	ctx context.Context
	ApiService BetaLibrariesDocumentsAPI
	libraryId string
	file *os.File
}

// The File object (not file name) to be uploaded.  To upload a file and specify a custom file name you should format your request as such:  &#x60;&#x60;&#x60;bash  file&#x3D;@path/to/your/file.jsonl;filename&#x3D;custom_name.jsonl  &#x60;&#x60;&#x60;  Otherwise, you can just keep the original file name:  &#x60;&#x60;&#x60;bash  file&#x3D;@path/to/your/file.jsonl  &#x60;&#x60;&#x60;
func (r ApiLibrariesDocumentsUploadV1Request) File(file *os.File) ApiLibrariesDocumentsUploadV1Request {
	r.file = file
	return r
}

func (r ApiLibrariesDocumentsUploadV1Request) Execute() (*DocumentOut, *http.Response, error) {
	return r.ApiService.LibrariesDocumentsUploadV1Execute(r)
}

/*
LibrariesDocumentsUploadV1 Upload a new document.

Given a library, upload a new document to that library. It is queued for processing, it status will change it has been processed. The processing has to be completed in order be discoverable for the library search

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param libraryId
 @return ApiLibrariesDocumentsUploadV1Request
*/
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsUploadV1(ctx context.Context, libraryId string) ApiLibrariesDocumentsUploadV1Request {
	return ApiLibrariesDocumentsUploadV1Request{
		ApiService: a,
		ctx: ctx,
		libraryId: libraryId,
	}
}

// Execute executes the request
//  @return DocumentOut
func (a *BetaLibrariesDocumentsAPIService) LibrariesDocumentsUploadV1Execute(r ApiLibrariesDocumentsUploadV1Request) (*DocumentOut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaLibrariesDocumentsAPIService.LibrariesDocumentsUploadV1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/libraries/{library_id}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"library_id"+"}", url.PathEscape(parameterValueToString(r.libraryId, "libraryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
