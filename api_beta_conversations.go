/*
Mistral AI API

Our Chat Completion and Embeddings APIs specification. Create your account on [La Plateforme](https://console.mistral.ai) to get access and read the [docs](https://docs.mistral.ai) to learn how to use it.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistral

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type BetaConversationsAPI interface {

	/*
	AgentsApiV1ConversationsAppend Append new entries to an existing conversation.

	Run completion on the history of the conversation and the user entries. Return the new created entries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the conversation to which we append entries.
	@return ApiAgentsApiV1ConversationsAppendRequest
	*/
	AgentsApiV1ConversationsAppend(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsAppendRequest

	// AgentsApiV1ConversationsAppendExecute executes the request
	//  @return ConversationResponse
	AgentsApiV1ConversationsAppendExecute(r ApiAgentsApiV1ConversationsAppendRequest) (*ConversationResponse, *http.Response, error)

	/*
	AgentsApiV1ConversationsAppendStream Append new entries to an existing conversation.

	Run completion on the history of the conversation and the user entries. Return the new created entries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the conversation to which we append entries.
	@return ApiAgentsApiV1ConversationsAppendStreamRequest
	*/
	AgentsApiV1ConversationsAppendStream(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsAppendStreamRequest

	// AgentsApiV1ConversationsAppendStreamExecute executes the request
	//  @return ConversationEvents
	AgentsApiV1ConversationsAppendStreamExecute(r ApiAgentsApiV1ConversationsAppendStreamRequest) (*ConversationEvents, *http.Response, error)

	/*
	AgentsApiV1ConversationsGet Retrieve a conversation information.

	Given a conversation_id retrieve a conversation entity with its attributes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the conversation from which we are fetching metadata.
	@return ApiAgentsApiV1ConversationsGetRequest
	*/
	AgentsApiV1ConversationsGet(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsGetRequest

	// AgentsApiV1ConversationsGetExecute executes the request
	//  @return ResponseV1ConversationsGet
	AgentsApiV1ConversationsGetExecute(r ApiAgentsApiV1ConversationsGetRequest) (*ResponseV1ConversationsGet, *http.Response, error)

	/*
	AgentsApiV1ConversationsHistory Retrieve all entries in a conversation.

	Given a conversation_id retrieve all the entries belonging to that conversation. The entries are sorted in the order they were appended, those can be messages, connectors or function_call.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the conversation from which we are fetching entries.
	@return ApiAgentsApiV1ConversationsHistoryRequest
	*/
	AgentsApiV1ConversationsHistory(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsHistoryRequest

	// AgentsApiV1ConversationsHistoryExecute executes the request
	//  @return ConversationHistory
	AgentsApiV1ConversationsHistoryExecute(r ApiAgentsApiV1ConversationsHistoryRequest) (*ConversationHistory, *http.Response, error)

	/*
	AgentsApiV1ConversationsList List all created conversations.

	Retrieve a list of conversation entities sorted by creation time.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAgentsApiV1ConversationsListRequest
	*/
	AgentsApiV1ConversationsList(ctx context.Context) ApiAgentsApiV1ConversationsListRequest

	// AgentsApiV1ConversationsListExecute executes the request
	//  @return []AgentsApiV1ConversationsList200ResponseInner
	AgentsApiV1ConversationsListExecute(r ApiAgentsApiV1ConversationsListRequest) ([]AgentsApiV1ConversationsList200ResponseInner, *http.Response, error)

	/*
	AgentsApiV1ConversationsMessages Retrieve all messages in a conversation.

	Given a conversation_id retrieve all the messages belonging to that conversation. This is similar to retrieving all entries except we filter the messages only.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the conversation from which we are fetching messages.
	@return ApiAgentsApiV1ConversationsMessagesRequest
	*/
	AgentsApiV1ConversationsMessages(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsMessagesRequest

	// AgentsApiV1ConversationsMessagesExecute executes the request
	//  @return ConversationMessages
	AgentsApiV1ConversationsMessagesExecute(r ApiAgentsApiV1ConversationsMessagesRequest) (*ConversationMessages, *http.Response, error)

	/*
	AgentsApiV1ConversationsRestart Restart a conversation starting from a given entry.

	Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the original conversation which is being restarted.
	@return ApiAgentsApiV1ConversationsRestartRequest
	*/
	AgentsApiV1ConversationsRestart(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsRestartRequest

	// AgentsApiV1ConversationsRestartExecute executes the request
	//  @return ConversationResponse
	AgentsApiV1ConversationsRestartExecute(r ApiAgentsApiV1ConversationsRestartRequest) (*ConversationResponse, *http.Response, error)

	/*
	AgentsApiV1ConversationsRestartStream Restart a conversation starting from a given entry.

	Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId ID of the original conversation which is being restarted.
	@return ApiAgentsApiV1ConversationsRestartStreamRequest
	*/
	AgentsApiV1ConversationsRestartStream(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsRestartStreamRequest

	// AgentsApiV1ConversationsRestartStreamExecute executes the request
	//  @return ConversationEvents
	AgentsApiV1ConversationsRestartStreamExecute(r ApiAgentsApiV1ConversationsRestartStreamRequest) (*ConversationEvents, *http.Response, error)

	/*
	AgentsApiV1ConversationsStart Create a conversation and append entries to it.

	Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAgentsApiV1ConversationsStartRequest
	*/
	AgentsApiV1ConversationsStart(ctx context.Context) ApiAgentsApiV1ConversationsStartRequest

	// AgentsApiV1ConversationsStartExecute executes the request
	//  @return ConversationResponse
	AgentsApiV1ConversationsStartExecute(r ApiAgentsApiV1ConversationsStartRequest) (*ConversationResponse, *http.Response, error)

	/*
	AgentsApiV1ConversationsStartStream Create a conversation and append entries to it.

	Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAgentsApiV1ConversationsStartStreamRequest
	*/
	AgentsApiV1ConversationsStartStream(ctx context.Context) ApiAgentsApiV1ConversationsStartStreamRequest

	// AgentsApiV1ConversationsStartStreamExecute executes the request
	//  @return ConversationEvents
	AgentsApiV1ConversationsStartStreamExecute(r ApiAgentsApiV1ConversationsStartStreamRequest) (*ConversationEvents, *http.Response, error)
}

// BetaConversationsAPIService BetaConversationsAPI service
type BetaConversationsAPIService service

type ApiAgentsApiV1ConversationsAppendRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
	conversationAppendRequest *ConversationAppendRequest
}

func (r ApiAgentsApiV1ConversationsAppendRequest) ConversationAppendRequest(conversationAppendRequest ConversationAppendRequest) ApiAgentsApiV1ConversationsAppendRequest {
	r.conversationAppendRequest = &conversationAppendRequest
	return r
}

func (r ApiAgentsApiV1ConversationsAppendRequest) Execute() (*ConversationResponse, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsAppendExecute(r)
}

/*
AgentsApiV1ConversationsAppend Append new entries to an existing conversation.

Run completion on the history of the conversation and the user entries. Return the new created entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the conversation to which we append entries.
 @return ApiAgentsApiV1ConversationsAppendRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsAppend(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsAppendRequest {
	return ApiAgentsApiV1ConversationsAppendRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationResponse
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsAppendExecute(r ApiAgentsApiV1ConversationsAppendRequest) (*ConversationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsAppend")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversationAppendRequest == nil {
		return localVarReturnValue, nil, reportError("conversationAppendRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conversationAppendRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsAppendStreamRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
	conversationAppendStreamRequest *ConversationAppendStreamRequest
}

func (r ApiAgentsApiV1ConversationsAppendStreamRequest) ConversationAppendStreamRequest(conversationAppendStreamRequest ConversationAppendStreamRequest) ApiAgentsApiV1ConversationsAppendStreamRequest {
	r.conversationAppendStreamRequest = &conversationAppendStreamRequest
	return r
}

func (r ApiAgentsApiV1ConversationsAppendStreamRequest) Execute() (*ConversationEvents, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsAppendStreamExecute(r)
}

/*
AgentsApiV1ConversationsAppendStream Append new entries to an existing conversation.

Run completion on the history of the conversation and the user entries. Return the new created entries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the conversation to which we append entries.
 @return ApiAgentsApiV1ConversationsAppendStreamRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsAppendStream(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsAppendStreamRequest {
	return ApiAgentsApiV1ConversationsAppendStreamRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationEvents
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsAppendStreamExecute(r ApiAgentsApiV1ConversationsAppendStreamRequest) (*ConversationEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsAppendStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}#stream"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversationAppendStreamRequest == nil {
		return localVarReturnValue, nil, reportError("conversationAppendStreamRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conversationAppendStreamRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsGetRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
}

func (r ApiAgentsApiV1ConversationsGetRequest) Execute() (*ResponseV1ConversationsGet, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsGetExecute(r)
}

/*
AgentsApiV1ConversationsGet Retrieve a conversation information.

Given a conversation_id retrieve a conversation entity with its attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the conversation from which we are fetching metadata.
 @return ApiAgentsApiV1ConversationsGetRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsGet(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsGetRequest {
	return ApiAgentsApiV1ConversationsGetRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ResponseV1ConversationsGet
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsGetExecute(r ApiAgentsApiV1ConversationsGetRequest) (*ResponseV1ConversationsGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseV1ConversationsGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsHistoryRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
}

func (r ApiAgentsApiV1ConversationsHistoryRequest) Execute() (*ConversationHistory, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsHistoryExecute(r)
}

/*
AgentsApiV1ConversationsHistory Retrieve all entries in a conversation.

Given a conversation_id retrieve all the entries belonging to that conversation. The entries are sorted in the order they were appended, those can be messages, connectors or function_call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the conversation from which we are fetching entries.
 @return ApiAgentsApiV1ConversationsHistoryRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsHistory(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsHistoryRequest {
	return ApiAgentsApiV1ConversationsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationHistory
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsHistoryExecute(r ApiAgentsApiV1ConversationsHistoryRequest) (*ConversationHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}/history"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsListRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	page *int32
	pageSize *int32
}

func (r ApiAgentsApiV1ConversationsListRequest) Page(page int32) ApiAgentsApiV1ConversationsListRequest {
	r.page = &page
	return r
}

func (r ApiAgentsApiV1ConversationsListRequest) PageSize(pageSize int32) ApiAgentsApiV1ConversationsListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiAgentsApiV1ConversationsListRequest) Execute() ([]AgentsApiV1ConversationsList200ResponseInner, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsListExecute(r)
}

/*
AgentsApiV1ConversationsList List all created conversations.

Retrieve a list of conversation entities sorted by creation time.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAgentsApiV1ConversationsListRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsList(ctx context.Context) ApiAgentsApiV1ConversationsListRequest {
	return ApiAgentsApiV1ConversationsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AgentsApiV1ConversationsList200ResponseInner
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsListExecute(r ApiAgentsApiV1ConversationsListRequest) ([]AgentsApiV1ConversationsList200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AgentsApiV1ConversationsList200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsMessagesRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
}

func (r ApiAgentsApiV1ConversationsMessagesRequest) Execute() (*ConversationMessages, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsMessagesExecute(r)
}

/*
AgentsApiV1ConversationsMessages Retrieve all messages in a conversation.

Given a conversation_id retrieve all the messages belonging to that conversation. This is similar to retrieving all entries except we filter the messages only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the conversation from which we are fetching messages.
 @return ApiAgentsApiV1ConversationsMessagesRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsMessages(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsMessagesRequest {
	return ApiAgentsApiV1ConversationsMessagesRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationMessages
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsMessagesExecute(r ApiAgentsApiV1ConversationsMessagesRequest) (*ConversationMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsRestartRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
	conversationRestartRequest *ConversationRestartRequest
}

func (r ApiAgentsApiV1ConversationsRestartRequest) ConversationRestartRequest(conversationRestartRequest ConversationRestartRequest) ApiAgentsApiV1ConversationsRestartRequest {
	r.conversationRestartRequest = &conversationRestartRequest
	return r
}

func (r ApiAgentsApiV1ConversationsRestartRequest) Execute() (*ConversationResponse, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsRestartExecute(r)
}

/*
AgentsApiV1ConversationsRestart Restart a conversation starting from a given entry.

Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the original conversation which is being restarted.
 @return ApiAgentsApiV1ConversationsRestartRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsRestart(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsRestartRequest {
	return ApiAgentsApiV1ConversationsRestartRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationResponse
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsRestartExecute(r ApiAgentsApiV1ConversationsRestartRequest) (*ConversationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsRestart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversationRestartRequest == nil {
		return localVarReturnValue, nil, reportError("conversationRestartRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conversationRestartRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsRestartStreamRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationId string
	conversationRestartStreamRequest *ConversationRestartStreamRequest
}

func (r ApiAgentsApiV1ConversationsRestartStreamRequest) ConversationRestartStreamRequest(conversationRestartStreamRequest ConversationRestartStreamRequest) ApiAgentsApiV1ConversationsRestartStreamRequest {
	r.conversationRestartStreamRequest = &conversationRestartStreamRequest
	return r
}

func (r ApiAgentsApiV1ConversationsRestartStreamRequest) Execute() (*ConversationEvents, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsRestartStreamExecute(r)
}

/*
AgentsApiV1ConversationsRestartStream Restart a conversation starting from a given entry.

Given a conversation_id and an id, recreate a conversation from this point and run completion. A new conversation is returned with the new entries returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId ID of the original conversation which is being restarted.
 @return ApiAgentsApiV1ConversationsRestartStreamRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsRestartStream(ctx context.Context, conversationId string) ApiAgentsApiV1ConversationsRestartStreamRequest {
	return ApiAgentsApiV1ConversationsRestartStreamRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return ConversationEvents
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsRestartStreamExecute(r ApiAgentsApiV1ConversationsRestartStreamRequest) (*ConversationEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsRestartStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations/{conversation_id}/restart#stream"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversationRestartStreamRequest == nil {
		return localVarReturnValue, nil, reportError("conversationRestartStreamRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conversationRestartStreamRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsStartRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationRequest *ConversationRequest
}

func (r ApiAgentsApiV1ConversationsStartRequest) ConversationRequest(conversationRequest ConversationRequest) ApiAgentsApiV1ConversationsStartRequest {
	r.conversationRequest = &conversationRequest
	return r
}

func (r ApiAgentsApiV1ConversationsStartRequest) Execute() (*ConversationResponse, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsStartExecute(r)
}

/*
AgentsApiV1ConversationsStart Create a conversation and append entries to it.

Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAgentsApiV1ConversationsStartRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsStart(ctx context.Context) ApiAgentsApiV1ConversationsStartRequest {
	return ApiAgentsApiV1ConversationsStartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationResponse
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsStartExecute(r ApiAgentsApiV1ConversationsStartRequest) (*ConversationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsStart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversationRequest == nil {
		return localVarReturnValue, nil, reportError("conversationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conversationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAgentsApiV1ConversationsStartStreamRequest struct {
	ctx context.Context
	ApiService BetaConversationsAPI
	conversationStreamRequest *ConversationStreamRequest
}

func (r ApiAgentsApiV1ConversationsStartStreamRequest) ConversationStreamRequest(conversationStreamRequest ConversationStreamRequest) ApiAgentsApiV1ConversationsStartStreamRequest {
	r.conversationStreamRequest = &conversationStreamRequest
	return r
}

func (r ApiAgentsApiV1ConversationsStartStreamRequest) Execute() (*ConversationEvents, *http.Response, error) {
	return r.ApiService.AgentsApiV1ConversationsStartStreamExecute(r)
}

/*
AgentsApiV1ConversationsStartStream Create a conversation and append entries to it.

Create a new conversation, using a base model or an agent and append entries. Completion and tool executions are run and the response is appended to the conversation.Use the returned conversation_id to continue the conversation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAgentsApiV1ConversationsStartStreamRequest
*/
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsStartStream(ctx context.Context) ApiAgentsApiV1ConversationsStartStreamRequest {
	return ApiAgentsApiV1ConversationsStartStreamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConversationEvents
func (a *BetaConversationsAPIService) AgentsApiV1ConversationsStartStreamExecute(r ApiAgentsApiV1ConversationsStartStreamRequest) (*ConversationEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BetaConversationsAPIService.AgentsApiV1ConversationsStartStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/conversations#stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversationStreamRequest == nil {
		return localVarReturnValue, nil, reportError("conversationStreamRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/event-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.conversationStreamRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
